/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
import { __decorate } from "tslib";
import '../../elevation/elevation.js';
import '../../focus/focus-ring.js';
import '../../ripple/ripple.js';
import { html, isServer, LitElement, nothing } from 'lit';
import { property, query, queryAsync, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { when } from 'lit/directives/when.js';
import { requestUpdateOnAriaChange } from '../../aria/delegate.js';
import { dispatchActivationClick, isActivationClick } from '../../controller/events.js';
import { ripple } from '../../ripple/directive.js';
/**
 * Tab component.
 */
export class Tab extends LitElement {
    constructor() {
        super();
        /**
         * Styling variant to display, 'primary' or 'secondary' and can also
         * include `vertical`.
         * Defaults to `primary`.
         */
        this.variant = 'primary';
        /**
         * Whether or not the tab is `disabled`.
         */
        this.disabled = false;
        /**
         * Whether or not the tab is `selected`.
         **/
        this.selected = false;
        /**
         * Whether or not the tab is `focusable`.
         */
        this.focusable = false;
        /**
         * Whether or not the icon renders inline with label or stacked vertically.
         */
        this.inlineIcon = false;
        this.showRipple = false;
        this.handleActivationClick = (event) => {
            if (!isActivationClick((event)) || !this.button) {
                return;
            }
            this.focus();
            dispatchActivationClick(this.button);
        };
        this.getRipple = () => {
            this.showRipple = true;
            return this.ripple;
        };
        this.renderRipple = () => {
            return html `<md-ripple ?disabled="${this.disabled}"></md-ripple>`;
        };
        if (!isServer) {
            this.addEventListener('click', this.handleActivationClick);
        }
    }
    focus() {
        this.button?.focus();
    }
    blur() {
        this.button?.blur();
    }
    render() {
        const contentClasses = {
            'inline-icon': this.inlineIcon,
        };
        return html `
      <button
        class="button"
        role="tab"
        .tabIndex=${this.focusable && !this.disabled ? 0 : -1}
        aria-selected=${this.selected ? 'true' : 'false'}
        ?disabled=${this.disabled}
        aria-label=${this.ariaLabel || nothing}
        ${ripple(this.getRipple)}
      >
        <md-focus-ring inward></md-focus-ring>
        <md-elevation></md-elevation>
        ${when(this.showRipple, this.renderRipple)}
        <span class="touch"></span>
        <div class="content ${classMap(contentClasses)}">
          <slot name="icon"></slot>
          <span class="label">
            <slot></slot>
          </span>
          <div class="indicator"></div>
        </div>
      </button>`;
    }
    updated(changed) {
        if (changed.has('selected') && !this.disabled) {
            this.animateSelected();
        }
    }
    get tabs() {
        return this.parentElement;
    }
    animateSelected() {
        this.indicator.getAnimations().forEach(a => {
            a.cancel();
        });
        const frames = this.getKeyframes();
        if (frames !== null) {
            this.indicator.animate(frames, { duration: 400, easing: 'ease-out' });
        }
    }
    getKeyframes() {
        const reduceMotion = shouldReduceMotion();
        if (!this.selected) {
            return reduceMotion ? [{ 'opacity': 1 }, { 'transform': 'none' }] : null;
        }
        const from = {};
        const isVertical = this.variant.includes('vertical');
        const fromRect = (this.tabs?.previousSelectedItem?.indicator.getBoundingClientRect() ??
            {});
        const fromPos = isVertical ? fromRect.top : fromRect.left;
        const fromExtent = isVertical ? fromRect.height : fromRect.width;
        const toRect = this.indicator.getBoundingClientRect();
        const toPos = isVertical ? toRect.top : toRect.left;
        const toExtent = isVertical ? toRect.height : toRect.width;
        const axis = isVertical ? 'Y' : 'X';
        const scale = fromExtent / toExtent;
        if (!reduceMotion && fromPos !== undefined && toPos !== undefined &&
            !isNaN(scale)) {
            from['transform'] = `translate${axis}(${(fromPos - toPos).toFixed(4)}px) scale${axis}(${scale.toFixed(4)})`;
        }
        else {
            from['opacity'] = 0;
        }
        // note, including `transform: none` avoids quirky Safari behavior
        // that can hide the animation.
        return [from, { 'transform': 'none' }];
    }
}
_a = Tab;
(() => {
    requestUpdateOnAriaChange(_a);
})();
Tab.shadowRootOptions = { mode: 'open', delegatesFocus: true };
__decorate([
    property({ reflect: true })
], Tab.prototype, "variant", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], Tab.prototype, "disabled", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], Tab.prototype, "selected", void 0);
__decorate([
    property({ type: Boolean })
], Tab.prototype, "focusable", void 0);
__decorate([
    property({ type: Boolean })
], Tab.prototype, "inlineIcon", void 0);
__decorate([
    query('.button')
], Tab.prototype, "button", void 0);
__decorate([
    queryAsync('md-ripple')
], Tab.prototype, "ripple", void 0);
__decorate([
    query('.indicator')
], Tab.prototype, "indicator", void 0);
__decorate([
    state()
], Tab.prototype, "showRipple", void 0);
function shouldReduceMotion() {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}
//# sourceMappingURL=tab.js.map